<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cipher Text Detector</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.5/dist/tesseract.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            text-align: center;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }
        
        h1 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 24px;
        }
        
        p {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .content-container {
            display: flex;
            flex-direction: row;
            flex: 1;
            overflow: hidden;
        }
        
        #video-container {
            width: 60%;
            padding-right: 10px;
            display: flex;
            flex-direction: column;
        }
        
        #video {
            width: 100%;
            height: auto;
            max-height: 70vh;
            border: 2px solid #333;
            border-radius: 8px;
            object-fit: cover;
        }
        
        #result-container {
            width: 40%;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 8px;
            text-align: left;
            overflow-y: auto;
        }
        
        .result-box {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
            overflow-wrap: break-word;
            word-wrap: break-word;
            font-size: 14px;
        }
        
        #encrypted-text {
            background-color: #e6f7ff;
            border: 1px solid #91d5ff;
        }
        
        #decrypted-text {
            background-color: #f6ffed;
            border: 1px solid #b7eb8f;
        }
        
        .status {
            font-style: italic;
            color: #666;
            font-size: 14px;
        }
        
        .button-container {
            display: flex;
            justify-content: center;
            margin: 5px 0;
        }
        
        button {
            background-color: #1890ff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
            font-size: 14px;
        }
        
        button:hover {
            background-color: #40a9ff;
        }
        
        h2, h3 {
            margin-top: 5px;
            margin-bottom: 5px;
            font-size: 16px;
        }
        
        /* Landscape-specific adjustments */
        @media (orientation: landscape) {
            .content-container {
                flex-direction: row;
            }
        }
        
        /* Portrait fallback */
        @media (orientation: portrait) {
            .content-container {
                flex-direction: column;
            }
            
            #video-container, #result-container {
                width: 100%;
            }
            
            #video-container {
                padding-right: 0;
                padding-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>Cipher Text Detector</h1>
    <p>Point your camera at the encrypted Caesar cipher text (shift 3)</p>
    
    <div class="button-container">
        <button id="start-btn">Start Camera</button>
        <button id="switch-btn">Switch Camera</button>
        <button id="capture-btn">Capture & Decode</button>
    </div>
    
    <div class="content-container">
        <div id="video-container">
            <video id="video" autoplay playsinline></video>
        </div>
        
        <div id="result-container">
            <h2>Results:</h2>
            <p class="status" id="status">Waiting for text detection...</p>
            
            <h3>Encrypted Text:</h3>
            <div class="result-box" id="encrypted-text">No text detected yet</div>
            
            <h3>Decrypted Text:</h3>
            <div class="result-box" id="decrypted-text">No text decoded yet</div>
        </div>
    </div>
    
    <canvas id="canvas" style="display:none;"></canvas>
    
    <script>
        // DOM elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('start-btn');
        const switchButton = document.getElementById('switch-btn');
        const captureButton = document.getElementById('capture-btn');
        const statusText = document.getElementById('status');
        const encryptedTextDiv = document.getElementById('encrypted-text');
        const decryptedTextDiv = document.getElementById('decrypted-text');
        
        // Global variables
        let stream = null;
        let backCameraId = null;
        let frontCameraId = null;
        let currentCamera = 'back'; // Start with back camera
        let isProcessing = false;
        
        // Function to start camera
        async function startCamera() {
            try {
                // Get list of video devices
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                // Try to identify back and front cameras
                for (const device of videoDevices) {
                    const label = device.label.toLowerCase();
                    if (label.includes('back') || label.includes('rear') || label.includes('environment')) {
                        backCameraId = device.deviceId;
                    } else if (label.includes('front') || label.includes('face') || label.includes('user')) {
                        frontCameraId = device.deviceId;
                    }
                }
                
                // If we couldn't identify cameras by label, make educated guesses
                if (videoDevices.length >= 2 && !backCameraId && !frontCameraId) {
                    backCameraId = videoDevices[0].deviceId;
                    frontCameraId = videoDevices[1].deviceId;
                } else if (videoDevices.length === 1) {
                    backCameraId = videoDevices[0].deviceId;
                    frontCameraId = videoDevices[0].deviceId;
                }
                
                // Default constraints for back camera - optimized for landscape
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 },  // Higher width for landscape
                        height: { ideal: 1080 }, // Corresponding height
                        aspectRatio: { ideal: 16/9 } // Typical landscape aspect ratio
                    }
                };
                
                // If we have an explicit device ID, use it
                if (backCameraId) {
                    constraints.video.deviceId = { exact: backCameraId };
                    delete constraints.video.facingMode;
                }
                
                // Get stream
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                currentCamera = 'back';
                
                // Force landscape if possible
                if (screen.orientation && screen.orientation.lock) {
                    try {
                        await screen.orientation.lock('landscape');
                    } catch (err) {
                        console.log('Orientation lock not supported or permission denied');
                    }
                }
                
                startButton.textContent = 'Camera Active';
                statusText.textContent = 'Camera ready. Click "Capture & Decode" to detect text.';
            } catch (err) {
                console.error('Error accessing the camera:', err);
                statusText.textContent = 'Error accessing camera: ' + err.message;
            }
        }
        
        // Function to switch camera (between front and back)
        async function switchCamera() {
            try {
                const newCamera = currentCamera === 'back' ? 'front' : 'back';
                
                const constraints = {
                    video: {
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        aspectRatio: { ideal: 16/9 }
                    }
                };
                
                if (newCamera === 'back') {
                    if (backCameraId) {
                        constraints.video.deviceId = { exact: backCameraId };
                    } else {
                        constraints.video.facingMode = 'environment';
                    }
                } else {
                    if (frontCameraId) {
                        constraints.video.deviceId = { exact: frontCameraId };
                    } else {
                        constraints.video.facingMode = 'user';
                    }
                }
                
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                currentCamera = newCamera;
                
                statusText.textContent = `Switched to ${newCamera} camera. Click "Capture & Decode" to detect text.`;
            } catch (err) {
                console.error('Error switching camera:', err);
                statusText.textContent = 'Error switching camera: ' + err.message;
            }
        }
        
        // Function to capture image and recognize text
        async function captureAndDecode() {
            if (isProcessing) {
                statusText.textContent = "Still processing previous image, please wait...";
                return;
            }
            
            try {
                isProcessing = true;
                statusText.textContent = "Processing image...";
                
                // Set canvas dimensions to match video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Draw video frame to canvas
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Get image data from canvas
                const imageData = canvas.toDataURL('image/png');
                
                // Recognize text using Tesseract.js
                statusText.textContent = "Detecting text...";
                
                // Create a new worker
                const worker = await Tesseract.createWorker('eng');
                
                // Set parameters for better OCR performance
                await worker.setParameters({
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!.,? ',
                    tessjs_create_pdf: '0',
                    tessjs_create_hocr: '0',
                    tessjs_create_tsv: '0',
                    tessjs_create_box: '0',
                    tessjs_create_unlv: '0',
                    tessjs_create_osd: '0'
                });
                
                // Recognize text from image
                const result = await worker.recognize(imageData);
                const detectedText = result.data.text.trim();
                
                // Terminate worker after use
                await worker.terminate();
                
                if (detectedText.length > 0) {
                    encryptedTextDiv.textContent = detectedText;
                    
                    // Decrypt using Caesar cipher (shift 3)
                    const decryptedText = caesarDecrypt(detectedText, 3);
                    decryptedTextDiv.textContent = decryptedText;
                    
                    statusText.textContent = "Text detected and decrypted!";
                } else {
                    statusText.textContent = "No text detected. Try again with better lighting or positioning.";
                }
            } catch (err) {
                console.error('Error in text recognition:', err);
                statusText.textContent = "Error processing image: " + err.message;
            } finally {
                isProcessing = false;
            }
        }
        
        // Caesar cipher decryption function (shift is how many letters to shift back)
        function caesarDecrypt(text, shift) {
            return text.split('').map(char => {
                // Check if character is a letter
                if (/[a-zA-Z]/.test(char)) {
                    // Get ASCII code
                    const code = char.charCodeAt(0);
                    let shiftedCode;
                    
                    // Shift based on whether character is uppercase or lowercase
                    if (code >= 65 && code <= 90) { // Uppercase
                        shiftedCode = ((code - 65 - shift + 26) % 26) + 65;
                    } else if (code >= 97 && code <= 122) { // Lowercase
                        shiftedCode = ((code - 97 - shift + 26) % 26) + 97;
                    }
                    
                    return String.fromCharCode(shiftedCode);
                }
                // Return non-alphabetic characters unchanged
                return char;
            }).join('');
        }
        
        // Function to handle orientation changes
        function handleOrientationChange() {
            // Adjust UI based on orientation
            if (window.matchMedia("(orientation: landscape)").matches) {
                document.querySelector('.content-container').style.flexDirection = 'row';
                document.getElementById('video-container').style.width = '60%';
                document.getElementById('result-container').style.width = '40%';
            } else {
                document.querySelector('.content-container').style.flexDirection = 'column';
                document.getElementById('video-container').style.width = '100%';
                document.getElementById('result-container').style.width = '100%';
            }
        }
        
        // Event listeners
        startButton.addEventListener('click', startCamera);
        switchButton.addEventListener('click', switchCamera);
        captureButton.addEventListener('click', captureAndDecode);
        window.addEventListener('orientationchange', handleOrientationChange);
        
        // Initial orientation setup
        handleOrientationChange();
        
        // Start with back camera by default
        document.addEventListener('DOMContentLoaded', () => {
            startCamera();
        });
    </script>
</body>
</html>
