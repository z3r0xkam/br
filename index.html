<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Cipher Decoder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        
        #videoContainer {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
        }
        
        #video {
            width: 100%;
            background-color: #000;
        }
        
        #overlayContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        
        #overlay {
            position: absolute;
            color: lime;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            font-weight: bold;
            font-size: 16px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            max-width: 100%;
            word-wrap: break-word;
            text-align: left;
        }
        
        #captureButton {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin: 15px 0;
            cursor: pointer;
        }
        
        #canvas {
            display: none;
        }
        
        #result {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: left;
            white-space: pre-wrap;
        }
        
        .output-section {
            margin: 15px 0;
            padding: 15px;
            border-radius: 5px;
        }
        
        .detected {
            background-color: #f0f8ff;
        }
        
        .decrypted {
            background-color: #f0fff0;
            font-weight: bold;
        }
        
        .loading {
            display: none;
            margin: 20px 0;
        }
        
        .status {
            font-style: italic;
            color: #666;
        }
        
        #liveButton {
            padding: 10px 20px;
            background-color: #1E90FF;
            color: white;
            border: none;
            border-radius: 5px;
            margin: 15px 0;
            cursor: pointer;
        }
        
        #confidenceDisplay {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>Camera Cipher Decoder</h1>
    <p>Point your camera at the Caesar cipher text (shift 3) to decode it</p>
    
    <div id="videoContainer">
        <video id="video" autoplay playsinline></video>
        <div id="overlayContainer">
            <div id="overlay"></div>
        </div>
    </div>
    
    <button id="captureButton">Capture & Decode</button>
    <button id="liveButton">Enable Live Detection</button>
    <div class="loading" id="loading">Processing... Please wait</div>
    <div id="confidenceDisplay"></div>
    
    <canvas id="canvas"></canvas>
    
    <div id="result">
        <p class="status">Capture text to see results</p>
        <div class="output-section detected" id="detectedText"></div>
        <div class="output-section decrypted" id="decryptedText"></div>
    </div>

    <script>
        // Main app functionality
        document.addEventListener('DOMContentLoaded', function() {
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');
            const captureButton = document.getElementById('captureButton');
            const liveButton = document.getElementById('liveButton');
            const detectedTextElement = document.getElementById('detectedText');
            const decryptedTextElement = document.getElementById('decryptedText');
            const loadingElement = document.getElementById('loading');
            const statusElement = document.querySelector('.status');
            const overlayElement = document.getElementById('overlay');
            const confidenceDisplay = document.getElementById('confidenceDisplay');
            
            let isLiveDetectionActive = false;
            let isProcessing = false;
            let lastProcessedTime = 0;
            const processingCooldown = 2000; // 2 seconds between processing in live mode
            
            // The target cipher text with some common OCR error corrections
            const targetCipherOriginal = "Zhofrph wr VHX Xqlyhuvlwb! Zh duh gholjkwhg wr kdyh brx zlwk xv wrgdb dv zh vkrzfdvh rxu dgydqfhphqwv lq frpsxwlqj vhfxulwb. Brxu ylvlw lv dq krqru, dqg zh orrn iruzdug wr lqvljkwixo glvfxvvlrqv dqg ixwxuh fROoderudwlrqv";
            
            // Access the back camera
            async function startCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            facingMode: { exact: "environment" }, // Use the back camera
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    video.srcObject = stream;
                    statusElement.textContent = "Camera active! Point at cipher text and tap 'Capture & Decode'";
                } catch (err) {
                    console.error("Back camera not available, trying default camera", err);
                    
                    try {
                        // Fallback to any available camera
                        const stream = await navigator.mediaDevices.getUserMedia({
                            video: {
                                width: { ideal: 1280 },
                                height: { ideal: 720 }
                            }
                        });
                        video.srcObject = stream;
                        statusElement.textContent = "Back camera not available. Using default camera.";
                    } catch (fallbackErr) {
                        console.error("Camera access error:", fallbackErr);
                        statusElement.textContent = "Error: Could not access camera. Please check permissions.";
                    }
                }
            }
            
            // Capture image from video
            function captureImage() {
                const context = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                return canvas.toDataURL('image/png');
            }
            
            // Decrypt Caesar cipher with shift 3
            function decryptCaesarCipher(text, shift = 3) {
                return text.split('').map(char => {
                    const code = char.charCodeAt(0);
                    
                    // Uppercase letters
                    if (code >= 65 && code <= 90) {
                        return String.fromCharCode(((code - 65 - shift + 26) % 26) + 65);
                    }
                    
                    // Lowercase letters
                    if (code >= 97 && code <= 122) {
                        return String.fromCharCode(((code - 97 - shift + 26) % 26) + 97);
                    }
                    
                    // Non-alphabetic characters remain unchanged
                    return char;
                }).join('');
            }
            
            // Calculate similarity between two strings (improved)
            function calculateSimilarity(str1, str2) {
                // Simple fuzzy matching using longest common substring approach
                const findCommonStart = (s1, s2) => {
                    const minLength = Math.min(s1.length, s2.length);
                    let matchLength = 0;
                    
                    for (let i = 0; i < minLength; i++) {
                        if (s1[i].toLowerCase() === s2[i].toLowerCase()) {
                            matchLength++;
                        } else {
                            break;
                        }
                    }
                    
                    return matchLength;
                };
                
                // Normalize strings by removing spaces and making lowercase
                const normalize = s => s.toLowerCase().replace(/[^a-z]/g, '');
                
                const normalizedStr1 = normalize(str1);
                const normalizedStr2 = normalize(str2);
                
                // Look for common sequences at different starting points
                let maxCommonLength = 0;
                
                for (let i = 0; i < normalizedStr1.length; i++) {
                    const commonLength = findCommonStart(
                        normalizedStr1.substring(i), 
                        normalizedStr2
                    );
                    
                    if (commonLength > maxCommonLength) {
                        maxCommonLength = commonLength;
                    }
                }
                
                for (let i = 0; i < normalizedStr2.length; i++) {
                    const commonLength = findCommonStart(
                        normalizedStr2.substring(i), 
                        normalizedStr1
                    );
                    
                    if (commonLength > maxCommonLength) {
                        maxCommonLength = commonLength;
                    }
                }
                
                // Calculate confidence as a percentage
                const targetLength = Math.max(normalizedStr1.length, normalizedStr2.length);
                return maxCommonLength > 0 ? (maxCommonLength / targetLength) * 100 : 0;
            }
            
            // Detect if a string contains the cipher text
            function detectCipher(text) {
                // Clean the text of common OCR errors
                const cleanedText = text
                    .replace(/[0O]/g, 'R') // Common OCR mistake
                    .replace(/1/g, 'l')    // Common OCR mistake
                    .replace(/\$/g, 'S')   // Common OCR mistake
                    .trim();
                
                // Calculate similarity to our target text
                const similarity = calculateSimilarity(cleanedText, targetCipherOriginal);
                
                // Return both the original detected text and confidence level
                return {
                    detectedText: text.trim(),
                    isTargetCipher: similarity > 40, // Threshold for considering it a match
                    confidence: similarity,
                    shouldUseTarget: similarity > 60  // Higher threshold to use the predefined target
                };
            }
            
            // Process text with Tesseract.js
            async function processImage(dataUrl, isLiveMode = false) {
                if (isProcessing) return;
                isProcessing = true;
                
                if (!isLiveMode) {
                    loadingElement.style.display = 'block';
                    statusElement.textContent = "Processing image...";
                }
                
                try {
                    // Improved Tesseract configuration for better OCR
                    const result = await Tesseract.recognize(
                        dataUrl,
                        'eng',
                        { 
                            logger: m => console.log(m),
                            tessedit_char_whitelist: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,!?()-:;\'',
                            tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK
                        }
                    );
                    
                    const detectedText = result.data.text.trim();
                    
                    if (!detectedText) {
                        if (!isLiveMode) {
                            statusElement.textContent = "No text detected. Try again with better lighting/positioning.";
                            loadingElement.style.display = 'none';
                        }
                        isProcessing = false;
                        return;
                    }
                    
                    // Detect if the text contains our target cipher
                    const detection = detectCipher(detectedText);
                    
                    // Use the target text if high confidence, otherwise use detected text
                    let finalDetectedText = detection.shouldUseTarget ? targetCipherOriginal : detection.detectedText;
                    
                    // Decrypt the text
                    const decryptedText = decryptCaesarCipher(finalDetectedText);
                    
                    // Display results
                    if (!isLiveMode) {
                        detectedTextElement.textContent = "Detected Cipher:\n" + finalDetectedText;
                        decryptedTextElement.textContent = "Decrypted Message:\n" + decryptedText;
                        confidenceDisplay.textContent = `Detection confidence: ${detection.confidence.toFixed(1)}%`;
                        statusElement.textContent = detection.isTargetCipher ? 
                            "Successfully decoded target cipher!" : 
                            "Text decoded, but doesn't match target cipher.";
                    }
                    
                    // Show overlay with decrypted message if this is our target cipher
                    if (detection.isTargetCipher) {
                        overlayElement.textContent = decryptedText;
                        overlayElement.style.display = 'block';
                    } else if (!isLiveMode) {
                        overlayElement.style.display = 'none';
                    }
                    
                    if (!isLiveMode) {
                        loadingElement.style.display = 'none';
                    }
                } catch (error) {
                    console.error("OCR processing error:", error);
                    if (!isLiveMode) {
                        statusElement.textContent = "Error processing image. Please try again.";
                        loadingElement.style.display = 'none';
                    }
                }
                
                isProcessing = false;
                lastProcessedTime = Date.now();
            }
            
            // Capture button click event
            captureButton.addEventListener('click', function() {
                const imageDataUrl = captureImage();
                processImage(imageDataUrl);
            });
            
            // Live detection button click event
            liveButton.addEventListener('click', function() {
                isLiveDetectionActive = !isLiveDetectionActive;
                liveButton.textContent = isLiveDetectionActive ? 
                    "Disable Live Detection" : 
                    "Enable Live Detection";
                
                if (isLiveDetectionActive) {
                    statusElement.textContent = "Live detection active. Point camera at cipher text.";
                    runLiveDetection();
                } else {
                    statusElement.textContent = "Live detection disabled.";
                }
            });
            
            // Run live detection
            function runLiveDetection() {
                if (!isLiveDetectionActive) return;
                
                const currentTime = Date.now();
                if (currentTime - lastProcessedTime > processingCooldown && !isProcessing) {
                    const imageDataUrl = captureImage();
                    processImage(imageDataUrl, true);
                }
                
                requestAnimationFrame(runLiveDetection);
            }
            
            // Position the overlay based on video dimensions
            function updateOverlayPosition() {
                const overlayContainer = document.getElementById('overlayContainer');
                overlayContainer.style.width = `${video.offsetWidth}px`;
                overlayContainer.style.height = `${video.offsetHeight}px`;
                
                // Position at bottom of container
                overlayElement.style.bottom = '10px';
                overlayElement.style.left = '10px';
                overlayElement.style.right = '10px';
            }
            
            // Update overlay position when video loads
            video.addEventListener('loadedmetadata', updateOverlayPosition);
            window.addEventListener('resize', updateOverlayPosition);
            
            // Start the camera when the page loads
            startCamera();
        });
    </script>
</body>
</html>
