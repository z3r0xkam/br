<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cipher Text Detector</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.5/dist/tesseract.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            text-align: center;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }
        
        h1 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 24px;
        }
        
        p {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .content-container {
            display: flex;
            flex-direction: row;
            flex: 1;
            overflow: hidden;
        }
        
        #video-container {
            width: 60%;
            padding-right: 10px;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #video {
            width: 100%;
            height: auto;
            max-height: 70vh;
            border: 2px solid #333;
            border-radius: 8px;
            object-fit: cover;
        }
        
        #live-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding: 10px;
            box-sizing: border-box;
        }
        
        #live-decrypted-text {
            background-color: rgba(246, 255, 237, 0.8);
            border: 1px solid #b7eb8f;
            border-radius: 5px;
            padding: 5px;
            margin-bottom: 5px;
            text-align: left;
            font-weight: bold;
            color: #135200;
            max-width: 100%;
            word-wrap: break-word;
            display: none;
        }
        
        #result-container {
            width: 40%;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 8px;
            text-align: left;
            overflow-y: auto;
        }
        
        .result-box {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
            overflow-wrap: break-word;
            word-wrap: break-word;
            font-size: 14px;
        }
        
        #encrypted-text {
            background-color: #e6f7ff;
            border: 1px solid #91d5ff;
        }
        
        #decrypted-text {
            background-color: #f6ffed;
            border: 1px solid #b7eb8f;
        }
        
        .status {
            font-style: italic;
            color: #666;
            font-size: 14px;
        }
        
        .button-container {
            display: flex;
            justify-content: center;
            margin: 5px 0;
        }
        
        button {
            background-color: #1890ff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
            font-size: 14px;
        }
        
        button:hover {
            background-color: #40a9ff;
        }
        
        h2, h3 {
            margin-top: 5px;
            margin-bottom: 5px;
            font-size: 16px;
        }
        
        /* Live mode toggle */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px 0;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin: 0 10px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #1890ff;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        /* Landscape-specific adjustments */
        @media (orientation: landscape) {
            .content-container {
                flex-direction: row;
            }
        }
        
        /* Portrait fallback */
        @media (orientation: portrait) {
            .content-container {
                flex-direction: column;
            }
            
            #video-container, #result-container {
                width: 100%;
            }
            
            #video-container {
                padding-right: 0;
                padding-bottom: 10px;
            }
        }
        
        #error-message {
            color: red;
            font-weight: bold;
            margin: 10px 0;
        }
        
        #camera-permissions {
            background-color: #ffe58f;
            border: 1px solid #ffc53d;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <h1>Cipher Text Detector</h1>
    <p>Point your camera at the encrypted Caesar cipher text (shift 3)</p>
    
    <div id="camera-permissions">
        Please allow camera access when prompted. If you denied access, please click the camera icon in your address bar and allow access.
    </div>
    
    <div id="error-message"></div>
    
    <div class="button-container">
        <button id="start-btn">Start Camera</button>
        <button id="switch-btn">Switch Camera</button>
        <button id="capture-btn">Capture & Decode</button>
    </div>
    
    <div class="toggle-container">
        <span>Live Decryption:</span>
        <label class="toggle-switch">
            <input type="checkbox" id="live-mode-toggle">
            <span class="slider"></span>
        </label>
    </div>
    
    <div class="content-container">
        <div id="video-container">
            <video id="video" autoplay playsinline muted></video>
            <div id="live-overlay">
                <div id="live-decrypted-text"></div>
            </div>
        </div>
        
        <div id="result-container">
            <h2>Results:</h2>
            <p class="status" id="status">Waiting for camera to start...</p>
            
            <h3>Encrypted Text:</h3>
            <div class="result-box" id="encrypted-text">No text detected yet</div>
            
            <h3>Decrypted Text:</h3>
            <div class="result-box" id="decrypted-text">No text decoded yet</div>
        </div>
    </div>
    
    <canvas id="canvas" style="display:none;"></canvas>
    
    <script>
        // DOM elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('start-btn');
        const switchButton = document.getElementById('switch-btn');
        const captureButton = document.getElementById('capture-btn');
        const statusText = document.getElementById('status');
        const encryptedTextDiv = document.getElementById('encrypted-text');
        const decryptedTextDiv = document.getElementById('decrypted-text');
        const errorMessage = document.getElementById('error-message');
        const cameraPermissions = document.getElementById('camera-permissions');
        const liveModeToggle = document.getElementById('live-mode-toggle');
        const liveDecryptedText = document.getElementById('live-decrypted-text');
        
        // Global variables
        let stream = null;
        let backCameraId = null;
        let frontCameraId = null;
        let currentCamera = 'back'; // Start with back camera
        let isProcessing = false;
        let liveMode = false;
        let liveDetectionInterval = null;
        let tesseractWorker = null;
        
        // Function to display detailed error message
        function showError(message, err) {
            console.error(message, err);
            errorMessage.textContent = `${message}: ${err.message || err}`;
            errorMessage.style.display = 'block';
            
            // Show camera permissions message if it's likely a permissions issue
            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                cameraPermissions.style.display = 'block';
            }
        }
        
        // Function to clear error message
        function clearError() {
            errorMessage.textContent = '';
            errorMessage.style.display = 'none';
            cameraPermissions.style.display = 'none';
        }
        
        // Check if camera is supported
        function checkCameraSupport() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('Camera not supported in this browser', { message: 'Please try using a modern browser like Chrome, Firefox, or Safari' });
                return false;
            }
            return true;
        }
        
        // Initialize Tesseract worker
        async function initTesseract() {
            if (tesseractWorker) {
                return tesseractWorker;
            }
            
            try {
                // Create a new worker
                tesseractWorker = await Tesseract.createWorker();
                
                // Load and initialize with English language
                await tesseractWorker.loadLanguage('eng');
                await tesseractWorker.initialize('eng');
                
                // Set parameters for better OCR performance
                await tesseractWorker.setParameters({
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!.,? '
                });
                
                return tesseractWorker;
            } catch (err) {
                showError('Error initializing Tesseract', err);
                return null;
            }
        }
        
        // Function to start camera with simplified constraints
        async function startCamera() {
            if (!checkCameraSupport()) return;
            
            clearError();
            statusText.textContent = "Starting camera...";
            
            try {
                // Stop any existing stream
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                
                // Simple back camera request first
                try {
                    stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' },
                        audio: false
                    });
                    video.srcObject = stream;
                    await video.play(); // Explicitly try to play
                    currentCamera = 'back';
                    startButton.textContent = 'Camera Active';
                    statusText.textContent = 'Camera ready. Click "Capture & Decode" to detect text.';
                    
                    // Initialize Tesseract for possible live mode
                    await initTesseract();
                    
                    return;
                } catch (err) {
                    console.log('Could not access back camera, trying any camera:', err);
                }
                
                // If back camera fails, try with any camera
                stream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: false
                });
                video.srcObject = stream;
                await video.play(); // Explicitly try to play
                currentCamera = 'unknown';
                startButton.textContent = 'Camera Active';
                statusText.textContent = 'Camera ready. Click "Capture & Decode" to detect text.';
                
                // Initialize Tesseract for possible live mode
                await initTesseract();
            } catch (err) {
                showError('Error accessing camera', err);
                statusText.textContent = 'Failed to start camera. Check permissions.';
            }
        }
        
        // Function to switch camera (between front and back)
        async function switchCamera() {
            if (!checkCameraSupport()) return;
            clearError();
            
            try {
                const newFacingMode = currentCamera === 'back' ? 'user' : 'environment';
                
                // Stop current stream
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                
                // Try to switch camera
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: newFacingMode },
                    audio: false
                });
                
                video.srcObject = stream;
                await video.play(); // Explicitly try to play
                currentCamera = currentCamera === 'back' ? 'front' : 'back';
                
                statusText.textContent = `Switched to ${currentCamera} camera. Click "Capture & Decode" to detect text.`;
            } catch (err) {
                showError('Error switching camera', err);
            }
        }
        
        // Caesar cipher decryption function (shift is how many letters to shift back)
        function caesarDecrypt(text, shift) {
            return text.split('').map(char => {
                // Check if character is a letter
                if (/[a-zA-Z]/.test(char)) {
                    // Get ASCII code
                    const code = char.charCodeAt(0);
                    let shiftedCode;
                    
                    // Shift based on whether character is uppercase or lowercase
                    if (code >= 65 && code <= 90) { // Uppercase
                        shiftedCode = ((code - 65 - shift + 26) % 26) + 65;
                    } else if (code >= 97 && code <= 122) { // Lowercase
                        shiftedCode = ((code - 97 - shift + 26) % 26) + 97;
                    }
                    
                    return String.fromCharCode(shiftedCode);
                }
                // Return non-alphabetic characters unchanged
                return char;
            }).join('');
        }
        
        // Function to capture image and recognize text
        async function captureAndDecode() {
            if (!stream) {
                statusText.textContent = "Camera not started. Please start camera first.";
                return;
            }
            
            if (isProcessing) {
                statusText.textContent = "Still processing previous image, please wait...";
                return;
            }
            
            try {
                isProcessing = true;
                statusText.textContent = "Processing image...";
                
                // Set canvas dimensions to match video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Draw video frame to canvas
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Get image data from canvas
                const imageData = canvas.toDataURL('image/png');
                
                // Recognize text using Tesseract.js
                statusText.textContent = "Detecting text...";
                
                // Get worker
                const worker = await initTesseract();
                
                // Recognize text from image
                const result = await worker.recognize(imageData);
                const detectedText = result.data.text.trim();
                
                if (detectedText.length > 0) {
                    encryptedTextDiv.textContent = detectedText;
                    
                    // Decrypt using Caesar cipher (shift 3)
                    const decryptedText = caesarDecrypt(detectedText, 3);
                    decryptedTextDiv.textContent = decryptedText;
                    
                    statusText.textContent = "Text detected and decrypted!";
                } else {
                    statusText.textContent = "No text detected. Try again with better lighting or positioning.";
                }
            } catch (err) {
                showError('Error in text recognition', err);
                statusText.textContent = "Error processing image. See error message for details.";
            } finally {
                isProcessing = false;
            }
        }
        
        // Function to handle live decryption
        async function startLiveDecryption() {
            if (!stream) {
                statusText.textContent = "Camera not started. Please start camera first.";
                return false;
            }
            
            // Clear previous interval if exists
            if (liveDetectionInterval) {
                clearInterval(liveDetectionInterval);
            }
            
            // Initialize Tesseract if not already done
            if (!tesseractWorker) {
                try {
                    await initTesseract();
                } catch (err) {
                    showError('Error initializing Tesseract for live mode', err);
                    return false;
                }
            }
            
            // Show live decryption overlay
            liveDecryptedText.style.display = 'block';
            
            // Start detection interval
            let processing = false;
            liveDetectionInterval = setInterval(async () => {
                if (processing || !liveMode) return;
                
                try {
                    processing = true;
                    
                    // Set canvas dimensions to match video
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    // Draw video frame to canvas
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // Get image data from canvas
                    const imageData = canvas.toDataURL('image/png');
                    
                    // Recognize text using Tesseract.js
                    const result = await tesseractWorker.recognize(imageData);
                    const detectedText = result.data.text.trim();
                    
                    if (detectedText.length > 0) {
                        // Decrypt using Caesar cipher (shift 3)
                        const decryptedText = caesarDecrypt(detectedText, 3);
                        liveDecryptedText.textContent = decryptedText;
                    } else {
                        liveDecryptedText.textContent = "No text detected";
                    }
                } catch (err) {
                    console.error('Live decryption error:', err);
                    liveDecryptedText.textContent = "Error detecting text";
                } finally {
                    processing = false;
                }
            }, 1000); // Check every second
            
            return true;
        }
        
        // Function to stop live decryption
        function stopLiveDecryption() {
            if (liveDetectionInterval) {
                clearInterval(liveDetectionInterval);
                liveDetectionInterval = null;
            }
            
            liveDecryptedText.style.display = 'none';
        }
        
        // Function to toggle live mode
        async function toggleLiveMode() {
            liveMode = liveModeToggle.checked;
            
            if (liveMode) {
                statusText.textContent = "Live decryption mode activated";
                const success = await startLiveDecryption();
                if (!success) {
                    liveModeToggle.checked = false;
                    liveMode = false;
                }
            } else {
                stopLiveDecryption();
                statusText.textContent = "Live decryption mode deactivated";
            }
        }
        
        // Function to handle orientation changes
        function handleOrientationChange() {
            // Adjust UI based on orientation
            if (window.matchMedia("(orientation: landscape)").matches) {
                document.querySelector('.content-container').style.flexDirection = 'row';
                document.getElementById('video-container').style.width = '60%';
                document.getElementById('result-container').style.width = '40%';
            } else {
                document.querySelector('.content-container').style.flexDirection = 'column';
                document.getElementById('video-container').style.width = '100%';
                document.getElementById('result-container').style.width = '100%';
            }
        }
        
        // Clean up resources when page unloads
        window.addEventListener('beforeunload', () => {
            // Stop camera stream
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            // Terminate Tesseract worker
            if (tesseractWorker) {
                tesseractWorker.terminate();
            }
            
            // Clear intervals
            if (liveDetectionInterval) {
                clearInterval(liveDetectionInterval);
            }
        });
        
        // Event listeners
        startButton.addEventListener('click', startCamera);
        switchButton.addEventListener('click', switchCamera);
        captureButton.addEventListener('click', captureAndDecode);
        liveModeToggle.addEventListener('change', toggleLiveMode);
        window.addEventListener('orientationchange', handleOrientationChange);
        
        // Handle video play failures
        video.addEventListener('error', (e) => {
            showError('Video error', e.error || new Error('Unknown video error'));
        });
        
        // Initial orientation setup
        handleOrientationChange();
        
        // Auto-start camera with a delay to allow page to load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(startCamera, 500);
        });
    </script>
</body>
</html>
