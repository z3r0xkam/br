<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cipher Cracker 3000</title>
    <script src="https://cdn.jsdelivr.net/npm/webcam-easy@1.0.5/dist/webcam-easy.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.1/dist/tesseract.min.js"></script>
    <style>
        body { background: #1a1a1a; color: #0f0; font-family: 'Courier New', monospace; margin: 0; }
        video, canvas { width: 100%; max-width: 640px; margin: 10px auto; display: block; border: 2px solid #f00; }
        #output { margin: 20px; font-size: 18px; text-align: center; text-shadow: 0 0 5px #0f0; }
        .message-stack { display: flex; flex-direction: column; gap: 10px; }
        .encrypted { color: #f00; font-weight: bold; }
        .decrypted { color: #0f0; font-weight: bold; }
    </style>
</head>
<body>
    <video id="webcam" autoplay playsinline></video>
    <canvas id="canvas" style="display: none;"></canvas>
    <div id="output">Initializing Rebel Scan...</div>

    <script>
        const webcamElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('canvas');
        const outputElement = document.getElementById('output');
        
        // Target cipher text
        const targetCipher = "Zhofrph wr VHX Xqlyhuvlwb! Zh duh gholjkwhg wr kdyh brx zlwk xv wrgdb dv zh vkrzfdvh rxu dgydqfhphqwv lq frpsxwlqj vhfxulwb. Brxu ylvlw lv dq krqru, dqg zh orrn iruzdug wr lqvljkwixo glvfxvvlrqv dqg ixwxuh fROoderudwlrqv";
        
        // Initialize webcam with back camera
        const webcam = new Webcam(webcamElement, 'environment', canvasElement);
        
        webcam.start()
            .then(() => {
                console.log("Camera online, comrade!");
                detectText();
            })
            .catch(err => {
                console.log("Camera rebellion failed: ", err);
                outputElement.innerHTML = "Camera access denied. Check permissions, rebel!";
            });

        function decodeCaesarCipher(str, shift) {
            return str.split('').map(char => {
                if (char.match(/[a-zA-Z]/)) {
                    const code = char.charCodeAt(0);
                    const base = code >= 65 && code <= 90 ? 65 : 97;
                    return String.fromCharCode(((code - base - shift + 26) % 26) + base);
                }
                return char;
            }).join('');
        }

        async function detectText() {
            while (true) {
                // Capture frame
                const picture = webcam.snap();
                canvasElement.src = picture;

                // Enhance image for better detection
                const context = canvasElement.getContext('2d');
                const imgData = context.getImageData(0, 0, canvasElement.width, canvasElement.height);
                const data = imgData.data;

                // Simple contrast boost
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    const brightness = (r + g + b) / 3;
                    const contrast = brightness > 127 ? 255 : 0;
                    data[i] = data[i + 1] = data[i + 2] = contrast;
                }
                context.putImageData(imgData, 0, 0);

                // Recognize text
                const result = await Tesseract.recognize(
                    canvasElement,
                    'eng',
                    { 
                        logger: m => console.log(m),
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz !.,' // Restrict charset
                    }
                );

                let detectedText = result.data.text
                    .replace(/\s+/g, ' ')  // Normalize spacing
                    .replace(/[^a-zA-Z\s!.]/g, '')  // Strip junk
                    .trim();

                // Standardize to uppercase
                detectedText = detectedText.toUpperCase();

                // Fuzzy match with threshold (80% similarity)
                const similarity = calculateSimilarity(detectedText, targetCipher);
                if (similarity > 0.8) {
                    const decodedMessage = decodeCaesarCipher(targetCipher, 3);
                    outputElement.innerHTML = `
                        <div class="message-stack">
                            <div class="encrypted">Encrypted: ${targetCipher}</div>
                            <div class="decrypted">Decrypted: ${decodedMessage}</div>
                        </div>
                    `;
                    break;
                } else {
                    outputElement.innerHTML = `Scanning... Similarity: ${(similarity * 100).toFixed(2)}%`;
                }

                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }

        // Simple similarity check (Levenshtein distance)
        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            const longerLength = longer.length;
            if (longerLength === 0) return 1.0;
            const distance = levenshteinDistance(str1, str2);
            return (longerLength - distance) / longerLength;
        }

        function levenshteinDistance(str1, str2) {
            const matrix = Array(str2.length + 1).fill(null)
                .map(() => Array(str1.length + 1).fill(null));

            for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;

            for (let j = 1; j <= str2.length; j++) {
                for (let i = 1; i <= str1.length; i++) {
                    const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[j][i] = Math.min(
                        matrix[j][i - 1] + 1,
                        matrix[j - 1][i] + 1,
                        matrix[j - 1][i - 1] + indicator
                    );
                }
            }
            return matrix[str2.length][str1.length];
        }
    </script>
</body>
</html>
