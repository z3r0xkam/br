<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cipher Cracker 3000</title>
    <script src="https://cdn.jsdelivr.net/npm/webcam-easy@1.0.5/dist/webcam-easy.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.1/dist/tesseract.min.js"></script>
    <style>
        body { background: #1a1a1a; color: #0f0; font-family: 'Courier New', monospace; margin: 0; }
        video, canvas { width: 100%; max-width: 640px; margin: 10px auto; display: block; border: 2px solid #f00; }
        #output { margin: 20px; font-size: 18px; text-align: center; text-shadow: 0 0 5px #0f0; }
        .message-stack { display: flex; flex-direction: column; gap: 10px; }
        .encrypted { color: #f00; font-weight: bold; }
        .decrypted { color: #0f0; font-weight: bold; }
        #debug { font-size: 14px; color: #ff0; }
    </style>
</head>
<body>
    <video id="webcam" autoplay playsinline></video>
    <canvas id="canvas" style="display: none;"></canvas>
    <div id="output">Initializing Rebel Scan...</div>
    <div id="debug"></div>

    <script>
        const webcamElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('canvas');
        const outputElement = document.getElementById('output');
        const debugElement = document.getElementById('debug');
        
        const targetCipher = "Zhofrph wr VHX Xqlyhuvlwb! Zh duh gholjkwhg wr kdyh brx zlwk xv wrgdb dv zh vkrzfdvh rxu dgydqfhphqwv lq frpsxwlqj vhfxulwb. Brxu ylvlw lv dq krqru, dqg zh orrn iruzdug wr lqvljkwixo glvfxvvlrqv dqg ixwxuh fROoderudwlrqv";
        
        const webcam = new Webcam(webcamElement, 'environment', canvasElement);
        
        webcam.start()
            .then(() => {
                console.log("Camera online, comrade!");
                detectText();
            })
            .catch(err => {
                console.log("Camera rebellion failed: ", err);
                outputElement.innerHTML = "Camera access denied. Check permissions, rebel!";
            });

        function decodeCaesarCipher(str, shift) {
            return str.split('').map(char => {
                if (char.match(/[a-zA-Z]/)) {
                    const code = char.charCodeAt(0);
                    const base = code >= 65 && code <= 90 ? 65 : 97;
                    return String.fromCharCode(((code - base - shift + 26) % 26) + base);
                }
                return char;
            }).join('');
        }

        async function detectText() {
            while (true) {
                const picture = webcam.snap();
                canvasElement.src = picture;

                // Advanced preprocessing
                const context = canvasElement.getContext('2d');
                context.drawImage(webcamElement, 0, 0, canvasElement.width, canvasElement.height);
                const imgData = context.getImageData(0, 0, canvasElement.width, canvasElement.height);
                const data = imgData.data;

                // Grayscale and adaptive threshold
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b; // Proper grayscale
                    const threshold = gray > 150 ? 255 : 0; // Adaptive threshold
                    data[i] = data[i + 1] = data[i + 2] = threshold;
                }
                context.putImageData(imgData, 0, 0);

                const result = await Tesseract.recognize(
                    canvasElement,
                    'eng',
                    { 
                        logger: m => console.log(m),
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz !.,'
                    }
                );

                let detectedText = result.data.text
                    .replace(/\s+/g, ' ')
                    .replace(/[^a-zA-Z\s!.]/g, '')
                    .trim()
                    .toUpperCase();

                // Debug output
                debugElement.innerHTML = `Detected: "${detectedText}"<br>Confidence: ${result.data.confidence}%`;

                const similarity = calculateSimilarity(detectedText, targetCipher);
                if (similarity > 0.7 || detectedText.includes(targetCipher.slice(0, 20))) { // Lowered threshold + substring check
                    const decodedMessage = decodeCaesarCipher(targetCipher, 3);
                    outputElement.innerHTML = `
                        <div class="message-stack">
                            <div class="encrypted">Encrypted: ${targetCipher}</div>
                            <div class="decrypted">Decrypted: ${decodedMessage}</div>
                        </div>
                    `;
                    break;
                } else {
                    outputElement.innerHTML = `Scanning... Similarity: ${(similarity * 100).toFixed(2)}%`;
                }

                await new Promise(resolve => setTimeout(resolve, 1500));
            }
        }

        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            const longerLength = longer.length;
            if (longerLength === 0) return 1.0;
            const distance = levenshteinDistance(str1, str2);
            return (longerLength - distance) / longerLength;
        }

        function levenshteinDistance(str1, str2) {
            const matrix = Array(str2.length + 1).fill(null)
                .map(() => Array(str1.length + 1).fill(null));
            for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
            for (let j = 1; j <= str2.length; j++) {
                for (let i = 1; i <= str1.length; i++) {
                    const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[j][i] = Math.min(
                        matrix[j][i - 1] + 1,
                        matrix[j - 1][i] + 1,
                        matrix[j - 1][i - 1] + indicator
                    );
                }
            }
            return matrix[str2.length][str1.length];
        }
    </script>
</body>
</html>
